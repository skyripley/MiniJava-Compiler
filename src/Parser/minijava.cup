/**
 * CUP specification of the language grammar for a simple demo language.
 * Change this into the language grammar of MiniJava for your implementation.
 *
 */

package Parser;

import AST.*;
import java.util.*;
import java_cup.runtime.*;
import java_cup.runtime.ComplexSymbolFactory;

action code {:

	public int getReducedRow() {
		return parser.current_symbol.left;
	}

	public void isMain(String method) throws Exception {
		if (!method.equals("main")) {
			throw new Exception("Missing static main method!");
		}
	}


:};

parser code {:

	Symbol current_symbol;

	public void syntax_error(Symbol cur_token){
		System.out.println("Error on line " + cur_token.left + " and column " + cur_token.right);
	}
:};

scan with {:
	current_symbol = getScanner().next_token();
	return current_symbol;
:};

/* Terminals (lexical tokens returned by the scanner): */

/* reserved words */
terminal DISPLAY;
terminal CLASS;
terminal EXTENDS;
terminal PUBLIC;
terminal STATIC;
terminal VOID;
terminal MAIN;
terminal LENGTH;
terminal THIS;
terminal NEW;
terminal PRINTLN;

/* types and boolean reserved */
terminal STRING;
terminal INTEGER_TYPE;
terminal BOOLEAN_TYPE;
terminal TRUE;
terminal FALSE;

/* control flow */
terminal IF;
terminal ELSE;
terminal WHILE;
terminal RETURN;

/* operators */
terminal PLUS;
terminal BECOMES;
terminal MINUS;
terminal MULTIPLY;
terminal LT;
terminal NOT;
terminal DOT;
terminal COMMA;
terminal AND;

/* delimiters */
terminal LPAREN;
terminal RPAREN;
terminal SEMICOLON;
terminal LBRACKET;
terminal RBRACKET;
terminal LBRACE;
terminal RBRACE;

/* identifiers */
terminal String IDENTIFIER;
terminal Integer INTEGER_LITERAL;


/* Nonterminals (constructed by parser): */

non terminal Program program;
non terminal MainClass mainClass;
non terminal ClassDecl classDecl;
non terminal ClassDeclList classDeclList;
non terminal VarDecl varDecl;
non terminal VarDeclList varDeclList;
non terminal MethodDecl methodDecl;
non terminal Formal formal;
non terminal FormalList formalList;
non terminal MethodDeclList methodDeclList;
non terminal Type type;
non terminal Statement statement;
non terminal StatementList statementList;
non terminal Exp exp;
non terminal ExpList expList;
non terminal Identifier identifier;


/* Precedence declarations: */

precedence right BECOMES;
precedence left AND;
precedence left LT;
precedence left PLUS;
precedence left MINUS;
precedence left MULTIPLY;
precedence right NEW;
precedence right NOT;
precedence left DOT;


/* Productions: */

program ::= mainClass:mc classDeclList:cdl
                {: RESULT = new Program(mc, cdl, mcxleft); :};

mainClass ::= CLASS identifier:id LBRACE PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET identifier:id1 RPAREN LBRACE statement:s RBRACE RBRACE
                {: RESULT = new MainClass(id, id1, s, idxleft); :};

classDecl ::= CLASS identifier:id LBRACE varDeclList:vdl methodDeclList:mdl RBRACE
                            {: RESULT = new ClassDeclSimple(id, vdl, mdl, idxleft); :}
                            |
                            CLASS identifier:id LBRACE methodDeclList:mdl RBRACE
                            {: RESULT = new ClassDeclSimple(id, mdl, idxleft); :}
                            |
                            CLASS identifier:id EXTENDS identifier:id1 LBRACE varDeclList:vdl methodDeclList:mdl RBRACE
                            {: RESULT = new ClassDeclExtends(id, id1, vdl, mdl, idxleft); :};

classDeclList ::= classDecl:cd classDeclList:cdl
                            {:
                                if (cdl == null)
                                    cdl = new ClassDeclList(cdlxleft);
                                cdl.add(cd);
                                RESULT = cdl;
                            :}
                            |
                            classDecl:cd
                            {:
                                ClassDeclList cdl = new ClassDeclList(cdxleft);
                                cdl.add(cd);
                                RESULT = cdl;
                            :};

varDecl ::= type:t identifier:id SEMICOLON
                        {: RESULT = new VarDecl(t, id, txleft); :};

varDeclList ::= varDeclList:vdl varDecl:vd
                            {:
                                if (vdl == null)
                                    vdl = new VarDeclList(vdxleft);
                                vdl.add(vd);
                                RESULT = vdl;
                            :}
                            |
                            varDecl:vd
                            {:
                                VarDeclList vdl = new VarDeclList(vdxleft);
                                vdl.add(vd);
                                RESULT = vdl;
                            :};

methodDecl ::= PUBLIC type:t identifier:id LPAREN formalList:fl RPAREN LBRACE varDeclList:vdl statementList:sl RETURN exp:e SEMICOLON RBRACE
                {: RESULT = new MethodDecl(t, id, fl, vdl, sl, e, txleft); :};

methodDeclList ::= methodDecl:md methodDeclList:mdl
                            {:
                                if (mdl == null)
                                    mdl = new MethodDeclList(mdlxleft);
                                mdl.add(md);
                                RESULT = mdl;
                            :}
                            |
                            methodDecl:md
                            {:
                                MethodDeclList mdl = new MethodDeclList(mdxleft);
                                mdl.add(md);
                                RESULT = mdl;
                            :};

formal ::= type:t identifier:id
            {: RESULT = new Formal(t, id, txleft); :};

formalList ::= formal:f COMMA formalList:fl
            {:
                if (fl == null)
                    fl = new FormalList(fxleft);
                fl.add(f);
                RESULT = fl;
            :}
            |
            formal:f
            {:
                FormalList fl = new FormalList(fxleft);
                fl.add(f);
                RESULT = fl;
            :};

type ::= INTEGER_TYPE:it LBRACKET RBRACKET
            {: RESULT = new IntArrayType(itxleft); :}
            |
            BOOLEAN_TYPE:bt
            {: RESULT = new BooleanType(btxleft); :}
            |
            INTEGER_TYPE:it
            {: RESULT = new IntegerType(itxleft); :}
            |
            identifier:id
            {: RESULT = new IdentifierType(id.toString(), idxleft); :};

statement ::= LBRACE statementList:sl RBRACE
                {: RESULT = new Block(sl, slxleft); :}
                |
                IF LPAREN:l exp:e RPAREN statement:s ELSE statement:s1
                {: RESULT = new If(e, s, s1, lxleft); :}
                |
                WHILE LPAREN:l exp:e RPAREN statement:s
                {: RESULT = new While(e, s, lxleft); :}
                |
                PRINTLN:p LPAREN exp:e RPAREN SEMICOLON
                {: RESULT = new Print(e, pxleft); :}
                |
                identifier:i BECOMES:b exp:e SEMICOLON
                {: RESULT = new Assign(i, e, ixleft); :}
                |
                identifier:i LBRACKET exp:e RBRACKET BECOMES exp:e1 SEMICOLON
                {: RESULT = new ArrayAssign(i, e, e1, ixleft); :};

statementList ::= statement:s statementList:sl
                    {:
                        if (sl == null)
                            sl = new StatementList(slxleft);
                        sl.add(s);
                        RESULT = sl;
                    :}
                    |
                    statement:s
                    {:
                        StatementList sl = new StatementList(sxleft);
                        sl.add(s);
                        RESULT = sl;
                    :};

exp ::= exp:e AND exp:e1
                    {: RESULT = new And(e, e1, exleft); :}
                    |
                    exp:e LT exp:e1
                    {: RESULT = new LessThan(e, e1, exleft); :}
                    |
                    exp:e PLUS exp:e1
                    {: RESULT = new Plus(e, e1, exleft); :}
                    |
                    exp:e MINUS exp:e1
                    {: RESULT = new Minus(e, e1, exleft); :}
                    |
                    exp:e MULTIPLY exp:e1
                    {: RESULT = new Times(e, e1, exleft); :}
                    |
                    exp:e LBRACKET exp:e1 RBRACKET
                    {: RESULT = new ArrayLookup(e, e1, exleft); :}
                    |
                    exp:e DOT LENGTH
                    {: RESULT = new ArrayLength(e, exleft); :}
                    |
                    exp:e DOT identifier:id LPAREN expList:exl RPAREN
                    {: RESULT = new Call(e, id, exl, exleft); :}
                    |
                    exp:e DOT identifier:id LPAREN RPAREN
                    {: RESULT = new Call(e, id, exleft); :}
                    |
                    INTEGER_LITERAL:i
                    {:
                        RESULT = new IntegerLiteral(i, ixleft);
                    :}
                    |
                    TRUE:t
                    {: RESULT = new True(txleft); :}
                    |
                    FALSE:f
                    {: RESULT = new False(fxleft); :}
                    |
                    identifier:id
                    {: RESULT = new IdentifierExp(id.toString(), idxleft); :}
                    |
                    THIS:t
                    {: RESULT = new This(txleft); :}
                    |
                    NEW INTEGER_TYPE LBRACKET exp:e RBRACKET
                    {: RESULT = new NewArray(e, exleft); :}
                    |
                    NEW identifier:id LPAREN RPAREN
                    {: RESULT = new NewObject(id, idxleft); :}
                    |
                    NOT exp:e
                    {: RESULT = new Not(e, exleft); :}
                    |
                    LPAREN exp:e RPAREN
                    {: RESULT = e; :};

expList ::= exp:e COMMA expList:el
                    {:
                        if (el == null)
                            el = new ExpList(exleft);
                        el.add(e);
                        RESULT = el;
                    :}
                    |
                    exp:e
                    {:
                        ExpList el = new ExpList(exleft);
                        el.add(e);
                        RESULT = el;
                    :};

identifier ::= IDENTIFIER:id
                    {:
                        RESULT = new Identifier(id, idxleft);
                    :};
