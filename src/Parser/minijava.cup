/**
 * CUP specification of the language grammar for a simple demo language.
 * Change this into the language grammar of MiniJava for your implementation.
 *
 */

package Parser;

import AST.*;
import java.util.*;
import java_cup.runtime.*;

/* Terminals (lexical tokens returned by the scanner): */

/* reserved words */
terminal DISPLAY;
terminal CLASS;
terminal EXTENDS;
terminal PUBLIC;
terminal STATIC;
terminal VOID;
terminal MAIN;
terminal LENGTH;
terminal THIS;
terminal NEW;
terminal PRINTLN;

/* types and boolean reserved */
terminal STRING;
terminal INTEGER_TYPE;
terminal BOOLEAN_TYPE;
terminal TRUE;
terminal FALSE;

/* control flow */
terminal IF;
terminal ELSE;
terminal WHILE;
terminal RETURN;

/* operators */
terminal PLUS;
terminal BECOMES;
terminal MINUS;
terminal MULTIPLY;
terminal ADD;
terminal LT;
terminal NOT;
terminal DOT;
terminal COMMA;
terminal AND;

/* delimiters */
terminal LPAREN;
terminal RPAREN;
terminal SEMICOLON;
terminal LBRACKET;
terminal RBRACKET;
terminal LBRACE;
terminal RBRACE;

/* identifiers */
terminal String IDENTIFIER;
terminal Integer INTEGER_LITERAL;


/* Nonterminals (constructed by parser): */

nonterminal Program Program;
nonterminal MainClass MainClass;
nonterminal ClassDeclaration ClassDeclaration;
nonterminal ClassDeclarationChain ClassDeclarationChain;
nonterminal VarDeclaration VarDeclaration;
nonterminal VarDeclarationList VarDeclarationList;
nonterminal MethodDeclaration MethodDeclaration;
nonterminal Type Type;
nonterminal Statement Statement;
nonterminal Expression Expression;
nonterminal Identifier Identifier;

/**
 * nonterminal List<Statement> Program;
 * nonterminal Statement Statement;
 * nonterminal Assign AssignStatement;
 * nonterminal Display DisplayStatement;
 * nonterminal Exp Expression;
 * nonterminal Identifier Identifier;
*/


/* Precedence declarations: */

precedence left PLUS;


/* Productions: */

Program ::= MainClass:mc ClassDeclarationList:cdl
                {: RESULT = new Program(mc, cdl); :};

MainClass ::= CLASS Identifier:id LBRACE PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET Identifier:id1 RPAREN LBRACE Statement:s RBRACE RBRACE
                {: RESULT = new MainClass(id, id1, s); :};

ClassDeclaration ::= CLASS Identifier:id LBRACE VarDeclarationList:vdl MethodDeclarationList:mdl RBRACE
                            {: RESULT = new ClassDeclaration(id, vdl, mdl); :}
                        |
                        CLASS Identifier:id EXTENDS Identifier:id1 LBRACE VarDeclarationList:vdl MethodDeclarationList:mdl RBRACE
                            {: RESULT = new ClassDeclaration(id, id1, vdl, mdl); :};

ClassDeclarationList ::= ClassDeclaration:cd ClassDeclarationList:cdl
                            {:
                                if (cdl == null)
                                    cdl = new ClassDeclarationList();
                                cdl.addElement(cd);
                                RESULT = cdl;
                            :}
                            |
                            {: RESULT = new ClassDeclarationList(); :};

VarDeclaration ::= Type:t Identifier:id SEMICOLON
                        {: RESULT = new VarDeclaration(t, id); :}

VarDeclarationList ::= VarDeclaration:vd VarDeclarationList:vdl
                            {:
                                if (vdl == null)
                                    vdl = new VarDeclarationList();
                                vdl.add(vd);
                                RESULT = vdl;
                            :}
                            |
                            {: RESULT = new VarDeclarationList(); :};

MethodDeclaration ::= PUBLIC Type:t Identifier:id LPAREN RPAREN LBRACE VarDeclarationList:vdl StatementList:sl RETURN Expression:e SEMICOLON RBRACE
                            {: RESULT = new MethodDeclaration(t, id, vdl, sl, e); :}
                            |
                            # TODO : need to add csv parameter list

MethodDeclarationList ::= MethodDeclaration:md methodDeclarationList:mdl
                            {:
                                if (mdl == null)
                                    mdl = new MethodDeclarationList();
                                mdl.add(md);
                                RESULT = mdl;
                            :}
                            |
                            {: RESULT = new MethodDeclarationList(); :};

Type ::= INTEGER_TYPE LBRACE RBRACE
            {: RESULT = new IntArrayType(); :}
            |
            BOOLEAN_TYPE
            {: RESULT = new BooleanType(); :}
            |
            INTEGER_TYPE
            {: RESULT = new IntType(); :}
            |
            Identifier:id
            {: RESULT = new IdentifierType(id.toString()); :};

Statement ::= LBRACE StatementList:sl RBRACE
                {: RESULT = new StatementBlock(sl); :}
                |
                IF LPAREN Expression:e RPAREN Statement:s ELSE Statement:s1
                {: RESULT = new IfStatement(e, s, s1); :}
                |
                WHILE LPAREN Expression:e RPAREN Statement:s
                {: RESULT = new WhileStatement(e, s); :}
                |
                PRINTLN LPAREN Expression:e RPAREN SEMICOLON
                {: RESULT = new PrintStatement (e); :}
                |
                Identifier:i BECOMES Expression:e SEMICOLON
                {: RESULT = new AssignStatement(i, e); :}
                |
                Identifier:i LBRACKET Expression:e RBRACKET BECOMES Expression:e1 SEMICOLON
                {: RESULT = new ArrayAssignStatement(i, e, e1); :};

StatementList ::= Statement:s StatementList:sl
                    {:
                        if (sl == null)
                            sl = new StatementList();
                        sl.addElement(s);
                        RESULT = sl;
                    :}
                    |
                    {: RESULT = new StatementList(); :};

Expression ::= Expression:e AND Expression:e1
                    {: RESULT = new AndExpression(e, e1); :}
                    |
                    Expression:e LT Expression:e1
                    {: RESULT = new LTExpression(e, e1); :}
                    |
                    Expression:e PLUS Expression:e1
                    {: RESULT = new PlusExpression(e, e1); :}
                    |
                    Expression:e MINUS Expression:e1
                    {: RESULT = new MinusExpression(e, e1); :}
                    |
                    Expression:e MULTIPLY Expression:e1
                    {: RESULT = new MultiplyExpression(e, e1); :}
                    |
                    Expression:e LBRACKET Expression:e1 RBRACKET
                    {: RESULT = new ArrayLookup(e, e1); :}
                    |
                    Expression:e DOT LENGTH
                    {: RESULT = new ArrayLength(e); :}
                    |
                    Expression:e DOT Identifier:id LPAREN RPAREN
                    {: RESULT = new MethodCall(e, id); :}
                    |
                    Expression:e DOT Identifier:id LPAREN Expression:e1 ExpressionCSVList:ecl RPAREN
                    {: RESULT = new MethodCall(e, id, e1, ecl); :}
                    |
                    INTEGER_LITERAL:i
                    {:
                        Integer x = (Integer) i.getValue();
                        RESULT = new IntegerLiteral(x.intintValue(), i.getLine(), i.getCol());
                    :}
                    |
                    TRUE:
                    {: RESULT = new True(); :}
                    |
                    FALSE:
                    {: RESULT = new False(); :}
                    |
                    Identifier:id
                    {: RESULT = new Identifier(id); :}
                    |
                    THIS
                    {: RESULT = new This(); :}
                    |
                    NEW INT LBRACKET Expression:e RBRACKET
                    {: RESULT = new NewArray(e); :}
                    |
                    NEW Identifier:id LPAREN RPAREN
                    {: RESULT = new NewObject(id); :}
                    |
                    NOT Expression:e
                    {: RESULT = new NotExpression(e); :}
                    |
                    LPAREN Expression:e RPAREN
                    {: RESULT = new e; :};

Identifier ::= IDENTIFIER:id
                    {:
                        String s = (String) id.getValue();
                        RESULT = new Identifier(s, id.getLine(), id.getCol());
                    :}
