/**
 * CUP specification of the language grammar for a simple demo language.
 * Change this into the language grammar of MiniJava for your implementation.
 *
 */

package Parser;

import AST.*;
import java.util.*;
import java_cup.runtime.*;

action code {:

	public int getReducedRow() {
		return parser.current_symbol.left;
	}

	public void isMain(String method) throws Exception {
		if (!method.equals("main")) {
			throw new Exception("Missing static main method!");
		}
	}


:};

parser code {:

	Symbol current_symbol;

	public void syntax_error(Symbol cur_token){
		System.out.println("Error on line " + cur_token.left);
	}
:};

scan with {:
	current_symbol = getScanner().next_token();
	return current_symbol;
:};

/* Terminals (lexical tokens returned by the scanner): */

/* reserved words */
terminal CLASS;
terminal EXTENDS;
terminal PUBLIC;
terminal STATIC;
terminal VOID;
terminal MAIN;
terminal LENGTH;
terminal THIS;
terminal NEW;
terminal PRINTLN;

/* types and boolean reserved */
terminal STRING;
terminal INTEGER_TYPE;
terminal BOOLEAN_TYPE;
terminal TRUE;
terminal FALSE;

/* control flow */
terminal IF;
terminal ELSE;
terminal WHILE;
terminal RETURN;

/* operators */
terminal PLUS;
terminal BECOMES;
terminal MINUS;
terminal MULTIPLY;
terminal LT;
terminal NOT;
terminal DOT;
terminal COMMA;
terminal AND;

/* delimiters */
terminal LPAREN;
terminal RPAREN;
terminal SEMICOLON;
terminal LBRACKET;
terminal RBRACKET;
terminal LBRACE;
terminal RBRACE;

/* identifiers */
terminal String IDENTIFIER;
terminal Integer INTEGER_LITERAL;


/* Nonterminals (constructed by parser): */

non terminal Program program;
non terminal MainClass mainClass;
non terminal ClassDeclaration classDeclaration;
non terminal ClassDeclarationList classDeclarationList;
non terminal VarDeclaration varDeclaration;
non terminal VarDeclarationList varDeclarationList;
non terminal MethodDeclaration methodDeclaration;
non terminal ParameterList parameterList;
non terminal MethodDeclarationList methodDeclarationList;
non terminal Type type;
non terminal Statement statement;
non terminal StatementList statementList;
non terminal Expression expression;
non terminal ExpressionList expressionList;
non terminal Identifier identifier;


/* Precedence declarations: */

precedence right BECOMES;
precedence left AND;
precedence left LT;
precedence left PLUS;
precedence left MINUS;
precedence left MULTIPLY;
precedence right NEW;
precedence right NOT;
precedence left DOT;
precedence left LBRACKET;
precedence left RBRACKET;
precedence left LPAREN;
precedence left RPAREN;


/* Productions: */

program ::= mainClass:mc classDeclarationList:cdl
                {: RESULT = new Program(mc, cdl); :};

mainClass ::= CLASS identifier:id LBRACE PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET identifier:id1 RPAREN LBRACE statement:s RBRACE RBRACE
                {: RESULT = new MainClass(id, id1, s); :};

classDeclaration ::= CLASS identifier:id LBRACE varDeclarationList:vdl methodDeclarationList:mdl RBRACE
                            {: RESULT = new ClassDeclaration(id, vdl, mdl); :}
                            |
                            CLASS identifier:id EXTENDS identifier:id1 LBRACE varDeclarationList:vdl methodDeclarationList:mdl RBRACE
                            {: RESULT = new ClassDeclaration(id, id1, vdl, mdl); :};

classDeclarationList ::= classDeclaration:cd classDeclarationList:cdl
                            {:
                                if (cdl == null)
                                    cdl = new ClassDeclarationList();
                                cdl.addElement(cd);
                                RESULT = cdl;
                            :}
                            |
			    classDeclaration:cd
                            {: RESULT = new ClassDeclarationList(cd); :};

varDeclaration ::= type:t identifier:id SEMICOLON
                        {: RESULT = new VarDeclaration(t, id); :};

varDeclarationList ::= varDeclarationList:vdl varDeclaration:vd
                            {:
                                if (vdl == null)
                                    vdl = new VarDeclarationList();
                                vdl.add(vd);
                                RESULT = vdl;
                            :}
                            |
			    varDeclaration:vd
                            {: RESULT = new VarDeclarationList(vd); :};

methodDeclaration ::= PUBLIC type:t identifier:id LPAREN RPAREN LBRACE varDeclarationList:vdl statementList:sl RETURN expression:e SEMICOLON RBRACE
                            {: RESULT = new MethodDeclaration(t, id, vdl, sl, e); :}
                            |
                            PUBLIC type:t identifier:id LPAREN type:t1 identifier:id1 parameterList:pl RPAREN LBRACE varDeclarationList:vdl statementList:sl RETURN expression:e SEMICOLON RBRACE
                            {: RESULT = new MethodDeclaration(t, id, t1, id1, pl, vdl, sl, e); :};

parameterList ::= COMMA type:t identifier:id parameterList:pl
                    {:
                        Formal tmp = new Formal(t, id);
                        if (pl == null)
                            pl = new FormalList();
                        pl.addElement(tmp);
                        RESULT = pl;
                    :}
                    |
                    {: RESULT = new FormalList(); :};

methodDeclarationList ::= methodDeclaration:md methodDeclarationList:mdl
                            {:
                                if (mdl == null)
                                    mdl = new MethodDeclarationList();
                                mdl.add(md);
                                RESULT = mdl;
                            :}
                            |
			    methodDeclaration:md
                            {: RESULT = new MethodDeclarationList(md); :};

type ::= INTEGER_TYPE LBRACE RBRACE
            {: RESULT = new IntArrayType(); :}
            |
            BOOLEAN_TYPE
            {: RESULT = new BooleanType(); :}
            |
            INTEGER_TYPE
            {: RESULT = new IntType(); :}
            |
            identifier:id
            {: RESULT = new IdentifierType(id.toString()); :};

statement ::= LBRACE statementList:sl RBRACE
                {: RESULT = new StatementBlock(sl); :}
                |
                IF LPAREN:l expression:e RPAREN statement:s ELSE statement:s1
                {: RESULT = new IfStatement(e, s, s1, l.getLine(), l.getCol()); :}
                |
                WHILE LPAREN:l expression:e RPAREN statement:s
                {: RESULT = new WhileStatement(e, s, l.getLine(), l.getCol()); :}
                |
                PRINTLN LPAREN expression:e RPAREN SEMICOLON
                {: RESULT = new PrintStatement(e); :}
                |
                identifier:i BECOMES:b expression:e SEMICOLON
                {: RESULT = new AssignStatement(i, e, b.getLine(), b.getCol()); :}
                |
                identifier:i LBRACKET expression:e RBRACKET BECOMES:b expression:e1 SEMICOLON
                {: RESULT = new ArrayAssignStatement(i, e, e1, b.getLine(), b.getCol()); :};

statementList ::= statement:s statementList:sl
                    {:
                        if (sl == null)
                            sl = new StatementList();
                        sl.addElement(s);
                        RESULT = sl;
                    :}
                    |
		    statement:s
                    {: RESULT = new StatementList(s); :};

expression ::= expression:e AND:a expression:e1
                    {: RESULT = new AndExpression(e, e1, a.getLine(), a.getCol()); :}
                    |
                    expression:e LT:l expression:e1
                    {: RESULT = new LTExpression(e, e1, l.getLine(), l.getCol()); :}
                    |
                    expression:e PLUS:p expression:e1
                    {: RESULT = new PlusExpression(e, e1, p.getLine(), p.getCol()); :}
                    |
                    expression:e MINUS:m expression:e1
                    {: RESULT = new MinusExpression(e, e1, m.getLine(), m.getCol()); :}
                    |
                    expression:e MULTIPLY:m expression:e1
                    {: RESULT = new MultiplyExpression(e, e1, m.getLine(), m.getCol()); :}
                    |
                    expression:e LBRACKET expression:e1 RBRACKET
                    {: RESULT = new ArrayLookup(e, e1); :}
                    |
                    expression:e DOT:d LENGTH
                    {: RESULT = new ArrayLength(e, d.getLine(), d.getCol()); :}
                    |
                    expression:e DOT:d identifier:id LPAREN RPAREN
                    {: RESULT = new MethodCall(e, id, d.getLine(), d.getCol()); :}
                    |
                    expression:e DOT:d identifier:id LPAREN expression:e1 expressionList:ecl RPAREN
                    {: RESULT = new MethodCall(e, id, e1, ecl, d.getLine(), d.getCol()); :}
                    |
                    INTEGER_LITERAL:i
                    {:
                        Integer x = (Integer) i.getValue();
                        RESULT = new IntegerLiteral(x.intintValue(), i.getLine(), i.getCol());
                    :}
                    |
                    TRUE
                    {: RESULT = new True(); :}
                    |
                    FALSE
                    {: RESULT = new False(); :}
                    |
                    identifier:id
                    {: RESULT = new Identifier(id); :}
                    |
                    THIS:t
                    {: RESULT = new This(t.getLine(), t.getCol()); :}
                    |
                    NEW INTEGER_TYPE LBRACKET expression:e RBRACKET
                    {: RESULT = new NewArray(e); :}
                    |
                    NEW identifier:id LPAREN RPAREN
                    {: RESULT = new NewObject(id); :}
                    |
                    NOT:n expression:e
                    {: RESULT = new NotExpression(e, n.getLine(), n.getCol()); :}
                    |
                    LPAREN expression:e RPAREN
                    {: RESULT = e; :};

expressionList ::= COMMA expression:e expressionList:el
                    {:
                        if (el == null)
                            el = new ExpressionList();
                        el.addElement(e);
                        RESULT = el;
                    :}
                    |
                    {: RESULT = new ExpressionList(); :};

identifier ::= IDENTIFIER:id
                    {:
		    	String s = (String) id.getValue();
                        RESULT = new Identifier(id, id.getLine(), id.getCol());
                    :};
