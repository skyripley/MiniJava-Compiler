/**
 * CUP specification of the language grammar for a simple demo language.
 * Change this into the language grammar of MiniJava for your implementation.
 *
 */

package Parser;

import AST.*;
import java.util.*;
import java_cup.runtime.*;

/* Terminals (lexical tokens returned by the scanner): */

/* reserved words */
terminal DISPLAY;
terminal CLASS;
terminal EXTENDS;
terminal PUBLIC;
terminal STATIC;
terminal VOID;
terminal MAIN;
terminal LENGTH;
terminal THIS;
terminal NEW;
terminal PRINTLN;

/* types and boolean reserved */
terminal STRING;
terminal INTEGER_TYPE;
terminal BOOLEAN_TYPE;
terminal TRUE;
terminal FALSE;

/* control flow */
terminal IF;
terminal ELSE;
terminal WHILE;
terminal RETURN;

/* operators */
terminal PLUS;
terminal BECOMES;
terminal MINUS;
terminal MULTIPLY;
terminal ADD;
terminal LT;
terminal NOT;
terminal DOT;
terminal COMMA;
terminal AND;

/* delimiters */
terminal LPAREN;
terminal RPAREN;
terminal SEMICOLON;
terminal LBRACKET;
terminal RBRACKET;
terminal LBRACE;
terminal RBRACE;

/* identifiers */
terminal String IDENTIFIER;
terminal Integer INTEGER_LITERAL;


/* Nonterminals (constructed by parser): */

nonterminal Program program;
nonterminal MainClass mainClass;
nonterminal ClassDeclaration classDeclaration;
nonterminal ClassDeclarationChain classDeclarationList;
nonterminal VarDeclaration varDeclaration;
nonterminal VarDeclarationList varDeclarationList;
nonterminal MethodDeclaration methodDeclaration;
nonterminal MethodDeclarationList methodDeclarationList;
nonterminal Type type;
nonterminal Statement statement;
nonterminal StatementList statementList;
nonterminal Expression expression;
nonterminal Identifier identifier;

/**
 * nonterminal List<Statement> Program;
 * nonterminal Statement Statement;
 * nonterminal Assign AssignStatement;
 * nonterminal Display DisplayStatement;
 * nonterminal Exp Expression;
 * nonterminal Identifier Identifier;
*/


/* Precedence declarations: */

precedence left PLUS;


/* Productions: */

program ::= mainClass:mc classDeclarationList:cdl
                {: RESULT = new Program(mc, cdl); :};

mainClass ::= CLASS identifier:id LBRACE PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET identifier:id1 RPAREN LBRACE statement:s RBRACE RBRACE
                {: RESULT = new MainClass(id, id1, s); :};

classDeclaration ::= CLASS identifier:id LBRACE varDeclarationList:vdl methodDeclarationList:mdl RBRACE
                            {: RESULT = new ClassDeclaration(id, vdl, mdl); :}
                        |
                        CLASS identifier:id EXTENDS identifier:id1 LBRACE varDeclarationList:vdl methodDeclarationList:mdl RBRACE
                            {: RESULT = new ClassDeclaration(id, id1, vdl, mdl); :};

classDeclarationList ::= classDeclaration:cd classDeclarationList:cdl
                            {:
                                if (cdl == null)
                                    cdl = new ClassDeclarationList();
                                cdl.addElement(cd);
                                RESULT = cdl;
                            :}
                            |
                            {: RESULT = new ClassDeclarationList(); :};

varDeclaration ::= type:t identifier:id SEMICOLON
                        {: RESULT = new VarDeclaration(t, id); :}

varDeclarationList ::= varDeclaration:vd varDeclarationList:vdl
                            {:
                                if (vdl == null)
                                    vdl = new VarDeclarationList();
                                vdl.add(vd);
                                RESULT = vdl;
                            :}
                            |
                            {: RESULT = new VarDeclarationList(); :};

methodDeclaration ::= PUBLIC type:t identifier:id LPAREN RPAREN LBRACE varDeclarationList:vdl statementList:sl RETURN expression:e SEMICOLON RBRACE
                            {: RESULT = new MethodDeclaration(t, id, vdl, sl, e); :}
                            |
                            # TODO : need to add csv parameter list

methodDeclarationList ::= methodDeclaration:md methodDeclarationList:mdl
                            {:
                                if (mdl == null)
                                    mdl = new MethodDeclarationList();
                                mdl.add(md);
                                RESULT = mdl;
                            :}
                            |
                            {: RESULT = new MethodDeclarationList(); :};

type ::= INTEGER_TYPE LBRACE RBRACE
            {: RESULT = new IntArrayType(); :}
            |
            BOOLEAN_TYPE
            {: RESULT = new BooleanType(); :}
            |
            INTEGER_TYPE
            {: RESULT = new IntType(); :}
            |
            identifier:id
            {: RESULT = new IdentifierType(id.toString()); :};

statement ::= LBRACE statementList:sl RBRACE
                {: RESULT = new StatementBlock(sl); :}
                |
                IF LPAREN expression:e RPAREN statement:s ELSE statement:s1
                {: RESULT = new IfStatement(e, s, s1); :}
                |
                WHILE LPAREN expression:e RPAREN statement:s
                {: RESULT = new WhileStatement(e, s); :}
                |
                PRINTLN LPAREN expression:e RPAREN SEMICOLON
                {: RESULT = new PrintStatement (e); :}
                |
                identifier:i BECOMES expression:e SEMICOLON
                {: RESULT = new AssignStatement(i, e); :}
                |
                identifier:i LBRACKET expression:e RBRACKET BECOMES expression:e1 SEMICOLON
                {: RESULT = new ArrayAssignStatement(i, e, e1); :};

statementList ::= statement:s statementList:sl
                    {:
                        if (sl == null)
                            sl = new StatementList();
                        sl.addElement(s);
                        RESULT = sl;
                    :}
                    |
                    {: RESULT = new StatementList(); :};

expression ::= expression:e AND expression:e1
                    {: RESULT = new AndExpression(e, e1); :}
                    |
                    expression:e LT expression:e1
                    {: RESULT = new LTExpression(e, e1); :}
                    |
                    expression:e PLUS expression:e1
                    {: RESULT = new PlusExpression(e, e1); :}
                    |
                    expression:e MINUS expression:e1
                    {: RESULT = new MinusExpression(e, e1); :}
                    |
                    expression:e MULTIPLY expression:e1
                    {: RESULT = new MultiplyExpression(e, e1); :}
                    |
                    expression:e LBRACKET expression:e1 RBRACKET
                    {: RESULT = new ArrayLookup(e, e1); :}
                    |
                    expression:e DOT LENGTH
                    {: RESULT = new ArrayLength(e); :}
                    |
                    expression:e DOT identifier:id LPAREN RPAREN
                    {: RESULT = new MethodCall(e, id); :}
                    |
                    expression:e DOT identifier:id LPAREN expression:e1 expressionCSVList:ecl RPAREN
                    {: RESULT = new MethodCall(e, id, e1, ecl); :}
                    |
                    INTEGER_LITERAL:i
                    {:
                        Integer x = (Integer) i.getValue();
                        RESULT = new IntegerLiteral(x.intintValue(), i.getLine(), i.getCol());
                    :}
                    |
                    TRUE:
                    {: RESULT = new True(); :}
                    |
                    FALSE:
                    {: RESULT = new False(); :}
                    |
                    identifier:id
                    {: RESULT = new Identifier(id); :}
                    |
                    THIS
                    {: RESULT = new This(); :}
                    |
                    NEW INT LBRACKET expression:e RBRACKET
                    {: RESULT = new NewArray(e); :}
                    |
                    NEW identifier:id LPAREN RPAREN
                    {: RESULT = new NewObject(id); :}
                    |
                    NOT expression:e
                    {: RESULT = new NotExpression(e); :}
                    |
                    LPAREN expression:e RPAREN
                    {: RESULT = new e; :};

identifier ::= IDENTIFIER:id
                    {:
                        String s = (String) id.getValue();
                        RESULT = new Identifier(s, id.getLine(), id.getCol());
                    :}
