/**
 * CUP specification of the language grammar for a simple demo language.
 * Change this into the language grammar of MiniJava for your implementation.
 *
 */

package Parser;

import AST.*;
import java.util.*;
import java_cup.runtime.*;

/* Terminals (lexical tokens returned by the scanner): */

/* reserved words */
terminal DISPLAY;
terminal CLASS;
terminal EXTENDS;
terminal PUBLIC;
terminal STATIC;
terminal VOID;
terminal MAIN;
terminal LENGTH;
terminal THIS;
terminal NEW;
terminal PRINTLN;

/* types and boolean reserved */
terminal STRING;
terminal INTEGER_TYPE;
terminal BOOLEAN_TYPE;
terminal TRUE;
terminal FALSE;

/* control flow */
terminal IF;
terminal ELSE;
terminal WHILE;
terminal RETURN;

/* operators */
terminal PLUS;
terminal BECOMES;
terminal MINUS;
terminal MULTIPLY;
terminal ADD;
terminal LT;
terminal NOT;
terminal DOT;
terminal COMMA;
terminal AND;

/* delimiters */
terminal LPAREN;
terminal RPAREN;
terminal SEMICOLON;
terminal LBRACKET;
terminal RBRACKET;
terminal LBRACE;
terminal RBRACE;

/* identifiers */
terminal String IDENTIFIER;
terminal Integer INTEGER_LITERAL;


/* Nonterminals (constructed by parser): */

nonterminal Program Program;
nonterminal MainClass MainClass;
nonterminal ClassDeclaration ClassDeclaration;
nonterminal ClassDeclarationChain ClassDeclarationChain;
nonterminal VarDeclaration VarDeclaration;
nonterminal VarDeclarationList VarDeclarationList;
nonterminal MethodDeclaration MethodDeclaration;
nonterminal Type Type;
nonterminal Statement Statement;
nonterminal Expression Expression;
nonterminal Identifier Identifier;

/**
 * nonterminal List<Statement> Program;
 * nonterminal Statement Statement;
 * nonterminal Assign AssignStatement;
 * nonterminal Display DisplayStatement;
 * nonterminal Exp Expression;
 * nonterminal Identifier Identifier;
*/


/* Precedence declarations: */

precedence left PLUS;


/* Productions: */

Program ::= MainClass:mc ClassDeclarationList:cdl
                {: RESULT = new Program(mc, cdl); :};

MainClass ::= CLASS Identifier:id LBRACE PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET Identifier:id1 RPAREN LBRACE Statement:s RBRACE RBRACE
                {: RESULT = new MainClass(id, id1, s); :};

ClassDeclaration ::= CLASS Identifier:id LBRACE VarDeclarationList:vdl MethodDeclarationList:mdl RBRACE
                            {: RESULT = new ClassDeclaration(id, vdl, mdl); :}
                        |
                        CLASS Identifier:id EXTENDS Identifier:id1 LBRACE VarDeclarationList:vdl MethodDeclarationList:mdl RBRACE
                            {: RESULT = new ClassDeclaration(id, id1, vdl, mdl); :};

ClassDeclarationList ::= ClassDeclaration:cd ClassDeclarationList:cdl
                            {:
                                if (cdl == null)
                                    cdl = new ClassDeclarationList();
                                cdl.addElement(cd);
                                RESULT = cdl;
                            :}
                            |
                            {: RESULT = new ClassDeclarationList(); :};

VarDeclaration ::= Type:t Identifier:id SEMICOLON
                        {: RESULT = new VarDeclaration(t, id); :}

VarDeclarationList ::= VarDeclaration:vd VarDeclarationList:vdl
                            {:
                                if (vdl == null)
                                    vdl = new VarDeclarationList();
                                vdl.add(vd);
                                RESULT = vdl;
                            :}
                            |
                            {: RESULT = new VarDeclarationList(); :};

MethodDeclaration ::= PUBLIC Type:t Identifier:id LPAREN RPAREN LBRACE VarDeclarationList:vdl StatementList:sl RETURN Expression:e SEMICOLON RBRACE
                            {: RESULT = new MethodDeclaration(t, id, vdl, sl, e); :}
                            |
                            # TODO: Ended here

Program ::= Statement:s
            {: List<Statement> p = new LinkedList<Statement>();
               p.add(s);
               RESULT = p; :}
        | Program:p Statement:s
            {: p.add(s); RESULT = p; :};

Statement   ::= AssignStatement:s
                {: RESULT = s; :}
            | DisplayStatement:s
                {: RESULT = s; :};

AssignStatement ::= Identifier:id BECOMES Expression:expr SEMICOLON
                    {: RESULT = new Assign(id, expr, idxleft); :};

Identifier  ::= IDENTIFIER:id
                {: RESULT = new Identifier(id, idxleft); :};

DisplayStatement ::= DISPLAY:d Expression:expr SEMICOLON
                     {: RESULT = new Display(expr, dxleft); :};

Expression    ::= IDENTIFIER:name
            {: RESULT = new IdentifierExp(name, namexleft); :}
        | Expression:arg1 PLUS Expression:arg2
            {: RESULT = new Plus(arg1, arg2, arg1xleft); :}
        | LPAREN Expression:expr RPAREN
            {: RESULT = expr; :};
