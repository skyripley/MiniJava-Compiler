/**
 * CUP specification of the language grammar for a simple demo language.
 * Change this into the language grammar of MiniJava for your implementation.
 *
 */

package Parser;

import AST.*;
import java.util.*;
import java_cup.runtime.*;
import java_cup.runtime.ComplexSymbolFactory;
import java.lang.reflect.Field;

action code {:

	public int getReducedRow() {
		return parser.current_symbol.left;
	}

	public void isMain(String method) throws Exception {
		if (!method.equals("main")) {
			throw new Exception("Missing static main method!");
		}
	}
:};

parser code {:

	Symbol current_symbol;
	public boolean errorDetected = false;

	public void syntax_error(Symbol cur_token) {
	    System.out.println("Syntax error found!");
	    System.out.println("Current symbol is: " + cur_token);
	    System.out.println("Current symbol value is: " + cur_token.value);
		errorDetected = true;
	}
:};

scan with {:
	current_symbol = getScanner().next_token();
	return current_symbol;
:};

/* Terminals (lexical tokens returned by the scanner): */

/* reserved words */
terminal DISPLAY;
terminal CLASS;
terminal EXTENDS;
terminal PUBLIC;
terminal STATIC;
terminal VOID;
terminal MAIN;
terminal LENGTH;
terminal THIS;
terminal NEW;
terminal PRINTLN;

/* types and boolean reserved */
terminal STRING;
terminal INTEGER_TYPE;
terminal BOOLEAN_TYPE;
terminal TRUE;
terminal FALSE;

/* control flow */
terminal IF;
terminal ELSE;
terminal WHILE;
terminal RETURN;

/* operators */
terminal PLUS;
terminal BECOMES;
terminal MINUS;
terminal MULTIPLY;
terminal LT;
terminal NOT;
terminal DOT;
terminal COMMA;
terminal AND;

/* delimiters */
terminal LPAREN;
terminal RPAREN;
terminal SEMICOLON;
terminal LBRACKET;
terminal RBRACKET;
terminal LBRACE;
terminal RBRACE;

/* identifiers */
terminal String IDENTIFIER;
terminal Integer INTEGER_LITERAL;


/* Nonterminals (constructed by parser): */

non terminal Program program;
non terminal MainClass mainClass;
non terminal ClassDecl classDecl;
non terminal ClassDeclList classDeclList;
non terminal VarDecl varDecl;
non terminal VarDeclList varDeclList;
non terminal MethodDecl methodDecl;
non terminal Formal formal;
non terminal FormalList formalList;
non terminal MethodDeclList methodDeclList;
non terminal Type type;
non terminal Statement statement;
non terminal StatementList statementList;
non terminal Exp exp;
non terminal ExpList expList;
non terminal Identifier identifier;


/* Precedence declarations: */

precedence right BECOMES;
precedence left AND;
precedence left LT;
precedence left PLUS;
precedence left MINUS;
precedence left MULTIPLY;
precedence right NEW;
precedence right NOT;
precedence left DOT;


/* Productions: */

program ::= mainClass:mc classDeclList:cdl
            {: RESULT = new Program(mc, cdl, mcxleft); :};

mainClass ::= CLASS identifier:id LBRACE PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET identifier:id1 RPAREN LBRACE statement:s RBRACE RBRACE
            {: RESULT = new MainClass(id, id1, s, idxleft); :}
            |
            error RBRACE RBRACE;

classDecl ::= CLASS identifier:id LBRACE varDeclList:vdl methodDeclList:mdl RBRACE
            {: RESULT = new ClassDeclSimple(id, vdl, mdl, idxleft); :}
            |
            CLASS identifier:id LBRACE methodDeclList:mdl RBRACE
            {: RESULT = new ClassDeclSimple(id, mdl, idxleft); :}
            |
            CLASS identifier:id EXTENDS identifier:id1 LBRACE varDeclList:vdl methodDeclList:mdl RBRACE
            {: RESULT = new ClassDeclExtends(id, id1, vdl, mdl, idxleft); :}
            |
            CLASS identifier:id EXTENDS identifier:id1 LBRACE methodDeclList:mdl RBRACE
            {: RESULT = new ClassDeclExtends(id, id1, mdl, idxleft); :}
            |
            error RBRACE;

classDeclList ::= classDeclList:cdl classDecl:cd
            {:
                if (cdl == null)
                    cdl = new ClassDeclList(cdlxleft);
                cdl.add(cd);
                RESULT = cdl;
            :}
            |
            classDecl:cd
            {:
                ClassDeclList cdl = new ClassDeclList(cdxleft);
                cdl.add(cd);
                RESULT = cdl;
            :};

varDecl ::= type:t identifier:id SEMICOLON
            {: RESULT = new VarDecl(t, id, txleft); :}
            |
            type error SEMICOLON
            |
            error identifier SEMICOLON;

varDeclList ::= varDeclList:vdl varDecl:vd
            {:
                if (vdl == null)
                    vdl = new VarDeclList(vdxleft);
                vdl.add(vd);
                RESULT = vdl;
            :}
            |
            varDecl:vd
            {:
                VarDeclList vdl = new VarDeclList(vdxleft);
                vdl.add(vd);
                RESULT = vdl;
            :};

methodDecl ::= PUBLIC type:t identifier:id LPAREN formalList:fl RPAREN LBRACE varDeclList:vdl statementList:sl RETURN exp:e SEMICOLON RBRACE
            {: RESULT = new MethodDecl(t, id, fl, vdl, sl, e, txleft); :}
            |
            PUBLIC type:t identifier:id LPAREN RPAREN LBRACE varDeclList:vdl statementList:sl RETURN exp:e SEMICOLON RBRACE
            {: RESULT = new MethodDecl(t, id, vdl, sl, e, txleft); :}
            |
            PUBLIC type:t identifier:id LPAREN formalList:fl RPAREN LBRACE statementList:sl RETURN exp:e SEMICOLON RBRACE
            {: RESULT = new MethodDecl(t, id, fl, sl, e, txleft); :}
            |
            PUBLIC type:t identifier:id LPAREN RPAREN LBRACE statementList:sl RETURN exp:e SEMICOLON RBRACE
            {: RESULT = new MethodDecl(t, id, sl, e, txleft); :}
            |
            PUBLIC type:t identifier:id LPAREN formalList:fl RPAREN LBRACE RETURN exp:e SEMICOLON RBRACE
            {: RESULT = new MethodDecl(t, id, fl, e, txleft); :}
            |
            PUBLIC type:t identifier:id LPAREN RPAREN LBRACE RETURN exp:e SEMICOLON RBRACE
            {: RESULT = new MethodDecl(t, id, e, txleft); :}
            |
            error RBRACE;

methodDeclList ::= methodDeclList:mdl methodDecl:md
            {:
                if (mdl == null)
                    mdl = new MethodDeclList(mdlxleft);
                mdl.add(md);
                RESULT = mdl;
            :}
            |
            methodDecl:md
            {:
                MethodDeclList mdl = new MethodDeclList(mdxleft);
                mdl.add(md);
                RESULT = mdl;
            :};

formal ::= type:t identifier:id
            {: RESULT = new Formal(t, id, txleft); :};

formalList ::= formalList:fl COMMA formal:f
            {:
                if (fl == null)
                    fl = new FormalList(fxleft);
                fl.add(f);
                RESULT = fl;
            :}
            |
            formal:f
            {:
                FormalList fl = new FormalList(fxleft);
                fl.add(f);
                RESULT = fl;
            :};

type ::= INTEGER_TYPE:it LBRACKET RBRACKET
            {: RESULT = new IntArrayType(itxleft); :}
            |
            BOOLEAN_TYPE:bt
            {: RESULT = new BooleanType(btxleft); :}
            |
            INTEGER_TYPE:it
            {: RESULT = new IntegerType(itxleft); :}
            |
            identifier:id
            {: RESULT = new IdentifierType(id.toString(), idxleft); :};

statement ::= LBRACE statementList:sl RBRACE
            {: RESULT = new Block(sl, slxleft); :}
            |
            IF LPAREN:l exp:e RPAREN statement:s ELSE statement:s1
            {: RESULT = new If(e, s, s1, lxleft); :}
            |
            WHILE LPAREN:l exp:e RPAREN statement:s
            {: RESULT = new While(e, s, lxleft); :}
            |
            PRINTLN:p LPAREN exp:e RPAREN SEMICOLON
            {: RESULT = new Print(e, pxleft); :}
            |
            identifier:i BECOMES:b exp:e SEMICOLON
            {: RESULT = new Assign(i, e, ixleft); :}
            |
            identifier:i LBRACKET exp:e RBRACKET BECOMES exp:e1 SEMICOLON
            {: RESULT = new ArrayAssign(i, e, e1, ixleft); :}
            |
            error SEMICOLON;

statementList ::= statementList:sl statement:s
            {:
                if (sl == null)
                    sl = new StatementList(slxleft);
                sl.add(s);
                RESULT = sl;
            :}
            |
            statement:s
            {:
                StatementList sl = new StatementList(sxleft);
                sl.add(s);
                RESULT = sl;
            :};

exp ::= exp:e AND exp:e1
            {: RESULT = new And(e, e1, exleft); :}
            |
            exp:e LT exp:e1
            {: RESULT = new LessThan(e, e1, exleft); :}
            |
            exp:e PLUS exp:e1
            {: RESULT = new Plus(e, e1, exleft); :}
            |
            exp:e MINUS exp:e1
            {: RESULT = new Minus(e, e1, exleft); :}
            |
            exp:e MULTIPLY exp:e1
            {: RESULT = new Times(e, e1, exleft); :}
            |
            exp:e LBRACKET exp:e1 RBRACKET
            {: RESULT = new ArrayLookup(e, e1, exleft); :}
            |
            exp:e DOT LENGTH
            {: RESULT = new ArrayLength(e, exleft); :}
            |
            exp:e DOT identifier:id LPAREN expList:exl RPAREN
            {: RESULT = new Call(e, id, exl, exleft); :}
            |
            exp:e DOT identifier:id LPAREN RPAREN
            {: RESULT = new Call(e, id, exleft); :}
            |
            INTEGER_LITERAL:i
            {:
                RESULT = new IntegerLiteral(i, ixleft);
            :}
            |
            TRUE:t
            {: RESULT = new True(txleft); :}
            |
            FALSE:f
            {: RESULT = new False(fxleft); :}
            |
            identifier:id
            {: RESULT = new IdentifierExp(id.toString(), idxleft); :}
            |
            THIS:t
            {: RESULT = new This(txleft); :}
            |
            NEW INTEGER_TYPE LBRACKET exp:e RBRACKET
            {: RESULT = new NewArray(e, exleft); :}
            |
            NEW identifier:id LPAREN RPAREN
            {: RESULT = new NewObject(id, idxleft); :}
            |
            NOT exp:e
            {: RESULT = new Not(e, exleft); :}
            |
            LPAREN exp:e RPAREN
            {: RESULT = e; :};

expList ::= expList:el COMMA exp:e
            {:
                if (el == null)
                    el = new ExpList(exleft);
                el.add(e);
                RESULT = el;
            :}
            |
            exp:e
            {:
                ExpList el = new ExpList(exleft);
                el.add(e);
                RESULT = el;
            :};

identifier ::= IDENTIFIER:id
            {:
                RESULT = new Identifier(id, idxleft);
            :};
